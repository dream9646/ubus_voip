/******************************************************************
 *
 * Copyright (C) 2014 5V Technologies Ltd.
 * All Rights Reserved.
 *
 * This program is the proprietary software of 5V Technologies Ltd
 * and/or its licensors, and only be used, duplicated,
 * modified or distributed under the authorized license from 5VT.
 *
 * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
 * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
 *
 * Purpose : 5VT OMCI protocol stack
 * Module  : client_prog
 * File    : omci_client.c
 *
 ******************************************************************/

// A simple TCP client for traf server
// usage:
// omci_client                          - Connect to local traf server
// omci_client -c "find_inst DHCP"      - Send specified command to local traf server
// omci_client -a 192.168.100.10        - Connect to traf server from another PC

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <pthread.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>
#include <linux/unistd.h>

#define BUFSIZE			1024
#define DEFAULT_TCP_PORT_CHAR	3097

static int dstSocket;
static pthread_t recv_thread;
const char exit_command[] = "\nexit\n";
static int raw_mode_enable = 0;

#ifdef USE_READLINE
static int is_interactive = 0;
#include "editline.h"
#define RECV_PROMPT_SIZE 32
static char recv_prompt[RECV_PROMPT_SIZE];	// collect the prompt generated by remote server
static int recv_prompt_i = 0;
#define HELP_PAGE_SIZE 24
static int help_page = 0;
#include "clitree.h"
struct cli_node_t tree_root_g; 
#ifdef DIAG_HELPER
static int diag_help_enable = 0;
int diag_get_matchlist(char *input_line, int with_help, char ***av);
#endif

static char *
shell_unescape(char *rl_line_buffer)
{
	static char line[1024];
	char *p=rl_line_buffer;
	char *q=line;
	
	while (*p) {
		if (*p == '\\')
			p++;
		*q++=*p++;
		if (q-line ==1023)
			break;
	}
	*q = 0;
	return line;	
}	

static int
my_matchlist(char *line, int with_delim, int with_help, char ***av)
{
	char **matchlist=malloc(128 * sizeof(char*));
	int match = 0;
	
	// for omci cli
	{
		char **av1=NULL;
		int size = clitree_line_get_matchlist(&tree_root_g, line, with_help, &av1);
		int i;
		for (i=0; i<size; i++) {
			if (match < 127) {
				matchlist[match] = av1[i];	// use matchlist instead of av1/av2 to keep str pointer
				match++;
			} else {
				free(av1[i]);
			}
		}
		if (av1)
			free(av1);
	}
#ifdef DIAG_HELPER
	// for diag cli
	if (diag_help_enable) {
		char **av2=NULL;
		int size = diag_get_matchlist(line, with_help, &av2);
		int i;
		if (with_delim && match >0 && size >0) {	// both omci & diag has match, put a delimiter line
			if (match < 127) {
				matchlist[match] = strdup("---");
				match++;
			}
		}
		for (i=0; i<size; i++) {
			if (match < 127) {
				matchlist[match] = av2[i];	// use matchlist instead of av1/av2 to keep str pointer
				match++;
			} else {
				free(av2[i]);
			}
		}
		if (av2)
			free(av2);
	}
#endif	
	*av = matchlist;
	return match;
}

static el_status_t 
my_helper(void)
{
	char **matchlist = NULL;
	int match = my_matchlist(shell_unescape(rl_line_buffer), 1, 1, &matchlist);
	int i, page_total = (match + (HELP_PAGE_SIZE-1)) / HELP_PAGE_SIZE;

	if (page_total>0)
		help_page= help_page % page_total;
	else
		help_page= 0;

	fprintf(stdout, "\n");
	for (i=0; i<match; i++) {
		if ( i>= help_page*HELP_PAGE_SIZE && i < (help_page+1)*HELP_PAGE_SIZE)
			printf("%s\n", matchlist[i]);
		free(matchlist[i]);
	}
	if (matchlist)
		free(matchlist);

	if (page_total > 1)
		printf("%65s - page %d/%d -\n", "", help_page+1, (match+(HELP_PAGE_SIZE-1))/HELP_PAGE_SIZE);
	else
		printf("\n");
	help_page++;

	tty_puts(recv_prompt);
	tty_string(shell_unescape(rl_line_buffer));	
	return CSmove;
}

static char *
my_complete(char *token, int *single_match)
{
	char **matchlist = NULL;
	int match = my_matchlist(shell_unescape(rl_line_buffer), 0, 0, &matchlist);
	char *complete = clitree_get_complete_by_matchlist(token, matchlist, match);
	int i;

	for (i=0; i< match; i++)
		free(matchlist[i]);
	if (matchlist)
		free(matchlist);

	if (complete) {
		*single_match = 1;
		return strdup(complete);
	}	
	*single_match = 0;
	return NULL;
}

int
my_list_possible(char *token, char ***av)
{
	return my_matchlist(shell_unescape(rl_line_buffer), 1, 0, av);
}
#endif

static int
util_thread_sched(int policy, int priority)
{
	struct sched_param param;

	// set the priority and scheduler
	param.sched_priority = priority;
	if (pthread_setschedparam(pthread_self(), policy, &param) == -1)
	{
		perror("sched_setscheduler() err");
		return -1;
	}

	return 0;
}

/* strtrim : removes leading spaces of a string */
static inline char *
strtrim(char *s)
{
	if (s) {
		while (isspace(*s))
			s++;
	}
	return s;
}

void
terminal_raw_mode(void)
{
	struct termios old_tio, new_tio;

	tcgetattr(STDIN_FILENO, &old_tio);
	new_tio = old_tio;
	new_tio.c_lflag &= (~ICANON & ~ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
}

void
terminal_cooked_mode(void)
{
	struct termios old_tio, new_tio;
	// config terminal to cooked mode
	tcgetattr(STDIN_FILENO, &old_tio);
	new_tio = old_tio;
	new_tio.c_lflag |= ICANON | ECHO | ISIG;
	tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
}

void
atexit_hookfunc(void)
{
#ifdef USE_READLINE
	if (is_interactive) {
		rl_ttyset(1);
		write_history("/var/run/omci.cli.history");
	}
#endif
	terminal_cooked_mode();
}

void
send_str_to_server(const char *str)
{
	int i;
	char buf[2];		// only sending 1char each

	for (i = 0; i < strlen(str); i++) {
		buf[0] = str[i];
		// only sending 1 char
		if ((send(dstSocket, buf, 1, 0) < 0)) {
			perror("send() err");
			exit(1);
		}
	}
}

// recv thread is response for recv msg from server and display it //////////////////////
void *
recv_thread_func(void *scr_message)
{
	int i;
	int numrcv;
	char buffer[BUFSIZE];

	util_thread_sched(SCHED_RR, 10);

	//printf("omci_client: recv thread activated\n");

	while (1) {
		memset(&buffer, 0, sizeof(buffer));
		numrcv = recv(dstSocket, buffer, BUFSIZE, 0);

		if (numrcv < 0) {
			/* Error Handling */
			if (errno == EINTR)	// redo if recv abort because of interrupt
				continue;
			perror("recv() err");
			close(dstSocket);
			pthread_exit((void*)1);

		} else if (numrcv == 0) {
			/* Session Closed */
			printf("\nomci_client: session closed by server correctly\n");
			close(dstSocket);
			pthread_exit((void*)0);

		} else {	// numrcv > 0
			/* Receive Packet */
			for (i = 0; i < numrcv; i++) {
				putchar(buffer[i]);
				// print \n\n to seperate prompt & result in client -c "cmd" mode
				if (scr_message && i>2 && buffer[i] == ' ' && buffer[i-1] == '>' ) {
					scr_message = NULL;
					printf("\n\n");
				}
				fflush(stdout);
#ifdef USE_READLINE
				if (buffer[i] == '\n') {
					recv_prompt[0] = 0;
					recv_prompt_i = 0;
				} else {
					if (recv_prompt_i<RECV_PROMPT_SIZE-1) {
						recv_prompt[recv_prompt_i] = buffer[i];
						recv_prompt_i++;
						recv_prompt[recv_prompt_i] = 0;
					}
				}
#endif
			}
		}
	}
	return 0;
}

// main is response to get user input and send to server ////////////////////////////////
void
sig_handler(int sig)
{
	static int main_thread_id = -1;
	int thread_id = syscall(__NR_gettid);

	if (sig == 0) {
		main_thread_id = thread_id;
		return;
	}
	//printf("catch signal %d\n", sig);
	if (thread_id != main_thread_id)
		return;

	if (sig == SIGINT || sig == SIGALRM) {	// ctrl-c or timeout
		// send exit to server so server will close socket
		send_str_to_server(exit_command);
		// wait 10ms and expect recv thread can detect socket closed by remote server
		usleep(10 * 1000);
		// if wait timeout, close sock from client
		close(dstSocket);
		exit(0);
	} else if (sig == SIGTSTP) {	// terminal stop
		// restore sigtstp default action
		signal(SIGTSTP, SIG_DFL);
		// do what we want
		terminal_cooked_mode();
		// trigger sigtstp default action
		raise(SIGTSTP);
	} else if (sig == SIGCONT) {	// cont
		// do waht we want
		if (raw_mode_enable)
			terminal_raw_mode();
		// try to capture sigtstp again
		signal(SIGTSTP, sig_handler);
	}
}

int
main(int argc, char **argv)
{
	struct sockaddr_in dstAddr;
	char *hostname = 0;
	char *scr_message = 0;
	unsigned short portnum = 0;
	char *cmd_filename = 0;
	int timeout = 0;
	int i;
	void *ret=NULL;

	pthread_attr_t pattr;

	sig_handler(0);
	signal(SIGINT, sig_handler);
	signal(SIGTSTP, sig_handler);
	signal(SIGCONT, sig_handler);
	signal(SIGALRM, sig_handler);

	/* Handling parameters */
	for (i = 1; i < argc; i++) {
		if (!strcmp(argv[i], "-a")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"-a\" parameter needs network address\n");
				exit(1);
			} else {
				hostname = argv[i + 1];
				i++;
			}
		} else if (!strcmp(argv[i], "-t")) {
			if (i == argc - 1) {
				fprintf(stderr, "omci_client: \"-t\" parameter needs timeout\n");
				exit(1);
			} else {
				timeout = atoi(argv[i + 1]);
				i++;
			}
		} else if (!strcmp(argv[i], "-f")) {
			if (i == argc - 1) {
				fprintf(stderr, "omci_client: \"-f\" parameter needs filename\n");
				exit(1);
			} else {
				if (timeout <= 0) timeout = 60;
				alarm(timeout);	// timeout in 60 sec for 'omci -f filename'
				cmd_filename = argv[i + 1];
				i++;
			}
		} else if (!strcmp(argv[i], "-c")) {
			if (i == argc - 1) {
				fprintf(stderr, "omci_client: \"-c\" parameter needs command message\n");
				exit(1);
			} else {
				if (timeout <= 0) timeout = 10;
				alarm(timeout);	// timeout in 10sec for 'omci -c cmd'
				scr_message = argv[i + 1];
				i++;
			}
		} else if (!strcmp(argv[i], "-p")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"-p\" parameter needs port number\n");
				exit(1);
			} else {
				portnum = atoi(argv[i + 1]);
				i++;
			}
		} else if (!strcmp(argv[i], "-r")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"-r\" parameter needs [0|1]\n");
				exit(1);
			} else {
				raw_mode_enable = atoi(argv[i + 1]);
				i++;
			}
#ifdef USE_READLINE
		} else if (!strcmp(argv[i], "--save_tree")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"--save_tree\" parameter needs filename\n");
				exit(1);
			} else {
				if (clitree_load(&tree_root_g, "./omci.cli") <0 &&
				    clitree_load(&tree_root_g, "/etc/omci/omci.cli") <0) {
					fprintf(stderr, "omci.cli not found in . and /etc?\n");
					exit(1);
				}
				if (clitree_load_help(&tree_root_g, "./omci.help") <0 &&
				    clitree_load_help(&tree_root_g, "/etc/omci/omci.help") <0) {
					fprintf(stderr, "omci.help not found in . & /etc?\n");
					exit(1);
				}
				if (clitree_save_tree(&tree_root_g, argv[i + 1]) <0)
					exit(2);
				fprintf(stdout, "save tree to %s\n", argv[i + 1]);
				exit(0);
			}

		} else if (!strcmp(argv[i], "--save_cli")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"--save_cli\" parameter needs filename\n");
				exit(1);
			} else {
				if (clitree_load(&tree_root_g, "./omci.cli") <0 &&
				    clitree_load(&tree_root_g, "/etc/omci/omci.cli") <0) {
					fprintf(stderr, "omci.cli not found in . and /etc?\n");
					exit(1);
				}
				if (clitree_save_cli(&tree_root_g, argv[i + 1]) <0)
					exit(2);
				fprintf(stdout, "save cli to %s\n", argv[i + 1]);
				exit(0);
			}

		} else if (!strcmp(argv[i], "--save_help")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"--save_help\" parameter needs filename\n");
				exit(1);
			} else {
				if (clitree_load(&tree_root_g, "./omci.cli") <0 &&
				    clitree_load(&tree_root_g, "/etc/omci/omci.cli") <0) {
					fprintf(stderr, "omci.cli not found in . and /etc?\n");
					exit(1);
				}
				if (clitree_load_help(&tree_root_g, "./omci.help") <0 &&
				    clitree_load_help(&tree_root_g, "/etc/omci/omci.help") <0) {
					fprintf(stderr, "omci.help not found in . & /etc?\n");
					exit(1);
				}
				if (clitree_save_help(&tree_root_g, argv[i + 1]) <0)
					exit(2);
				fprintf(stdout, "save help to %s\n", argv[i + 1]);
				exit(0);
			}
		
		} else if (!strcmp(argv[i], "--save_validate")) {
			if (i == argc - 1 || (argv[i + 1][0] == '-')) {
				fprintf(stderr, "omci_client: \"--save_validate\" parameter needs filename\n");
				exit(1);
			} else {
				if (clitree_load(&tree_root_g, "./omci.cli") <0 &&
				    clitree_load(&tree_root_g, "/etc/omci/omci.cli") <0) {
					fprintf(stderr, "omci.cli not found in . and /etc?\n");
					exit(1);
				}
				if (clitree_load_validate(&tree_root_g, "./omci.validate") <0 &&
				    clitree_load_validate(&tree_root_g, "/etc/omci/omci.validate") <0) {
					fprintf(stderr, "omci.validate not found in . & /etc?\n");
					exit(1);
				}
				if (clitree_save_validate(&tree_root_g, argv[i + 1]) <0)
					exit(2);
				fprintf(stdout, "save validate to %s\n", argv[i + 1]);
				exit(0);
			}
		
		} else if (!strcmp(argv[i], "--hash_info")) {
			if (clitree_load(&tree_root_g, "./omci.cli") <0 &&
			    clitree_load(&tree_root_g, "/etc/omci/omci.cli") <0) {
				fprintf(stderr, "omci.cli not found in . and /etc?\n");
				exit(1);
			}
			clitree_hash_info_print();
			exit(0);				
#endif				
		} else if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
			printf("omci client (%s %s)\n\n", __DATE__, __TIME__);
			printf("usage: %s [OPTION]...\n", argv[0]);
			printf("  -t <seconds>			timeout for -c or -f (default 10s for -c, 60s for -f)\n");
			printf("  -c <command>			execute specified command\n");
			printf("  -f <fname>			execute command in the file.\n");
			printf("  -a <ipaddr>			specify server ipaddr (default:127.0.0.1)\n");
			printf("  -p <port>			specify server port (default:3097)\n");
			printf("  -r <rawmode>			raw mode enable (default:0)\n");
			printf("  --save_cli <fname>		save cli to filename\n");
			printf("  --save_help <fname>		save help to filename\n");
			printf("  --save_validate <fname>	save validate to filename\n");
			printf("  --hash_info			show hash info\n");
			printf("example:\n");
			printf("  omci_client -c \"misc version\" -a 192.168.100.10 -p 12345\n\n");
			exit(1);
		} else {
			// Wrong paramter specified
			fprintf(stderr, "omci_client: wrong parameter \"%s\"\n", argv[i]);
			exit(1);
		}
	}

	util_thread_sched(SCHED_RR, 10);

	// Using default
	if (!hostname) {
		hostname = "127.0.0.1";
		//printf("omci_client: using local host as default\n");
	}
	if (portnum == 0) {
		portnum = DEFAULT_TCP_PORT_CHAR;
		//printf("omci_client: using default port number\n");
	}

	/* socket: create the socket */
	if ((dstSocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("socket() err");
		exit(1);
	}

	/* Set address */
	memset(&dstAddr, 0, sizeof(dstAddr));
	dstAddr.sin_port = htons(portnum);
	dstAddr.sin_family = AF_INET;
	dstAddr.sin_addr.s_addr = inet_addr(hostname);

	// config terminal to raw mode
	if (raw_mode_enable)
		terminal_raw_mode();
	// config terminal to cooked mode when exit
	atexit(atexit_hookfunc);

	/* connecting */
	printf("omci_client: connecting to %s:%u\n", hostname, portnum);
	for (i = 0;; i++) {
		if ((connect(dstSocket, (struct sockaddr *)&dstAddr, sizeof(dstAddr))) == 0)
			break;
		if (i > 10) {	// retry in case server is not back to ready from previous connection
			perror("connect() err");
			exit(1);
		}
		printf(".");
		fflush(0);
		usleep(100 * 1000);	// 0.1s
	}
	// connection success
	printf("omci_client: session established\n");

	/* set thread create attributes */
	pthread_attr_init(&pattr);
	// default attribute is joinable
	//pthread_attr_setdetachstate(&pattr, PTHREAD_CREATE_DETACHED);	
	pthread_attr_setstacksize(&pattr, 128*1024);
	
	/* register pthread */
	if (pthread_create(&recv_thread, &pattr, (void *)recv_thread_func, scr_message) < 0) {
		perror("pthread_create() err");
		exit(1);
	}

	if (cmd_filename) {
		FILE *fp;
		char cmd[1024];

		if ((fp = fopen(cmd_filename, "r")) == NULL) {
			perror("fopen(cmdfile) err");
			exit(1);
		}
		while (fgets(cmd, 1024, fp) != NULL) {
			if (*strtrim(cmd) == '#')
				continue;
			send_str_to_server(cmd);
		}
		fclose(fp);

		send_str_to_server(exit_command);
		pthread_join(recv_thread, &ret);
		return (int)ret;

	} else if (scr_message) {
		send_str_to_server(scr_message);
		send_str_to_server(exit_command);
		pthread_join(recv_thread, &ret);
		return (int)ret;

	} else { /* Interactive Mode */
#ifdef USE_READLINE
		is_interactive = 1;
		// toggle rl_ttyset so rl_ttyset(1) could be called safely in atexit_hookfunc()
		rl_ttyset(0);	// save tty attr and set to raw mode
		rl_ttyset(1);	// restore tty attr
		
		rl_set_list_possib_func(&my_list_possible);
		rl_set_complete_func(&my_complete);
		el_bind_key('?', my_helper);
		if (clitree_load(&tree_root_g, "./omci.cli") <0 &&
		    clitree_load(&tree_root_g, "/etc/omci/omci.cli") <0) {
			fprintf(stderr, "omci.cli not found in . & /etc?\n");
		}
		if (clitree_load_help(&tree_root_g, "./omci.help") <0 &&
		    clitree_load_help(&tree_root_g, "/etc/omci/omci.help") <0) {
			fprintf(stderr, "omci.help not found in . & /etc?\n");
		}
		read_history("/var/run/omci.cli.history");
		while (1) {
			char *p = readline(recv_prompt);

			recv_prompt_i = 0;
			recv_prompt[0] = 0;
			help_page = 0;

			if (p == NULL) {
				send(dstSocket, "exit\n", 5, 0);
				printf("exit\n");
				break;

			} else if (strcmp(p, "diag") == 0) {
				system("diag");
#ifdef DIAG_HELPER
			} else if (strcmp(p, "diag+") == 0) {
				diag_help_enable = 1;
				printf("diag cli help enabled.\n");
			} else if (strcmp(p, "diag-") == 0) {
				diag_help_enable = 0;
				printf("diag cli help disabled.\n");
#endif
			} else if (strcmp(p, "gfast-cli") == 0) {
				system("telnet localhost:8000");
			} else {
				if ((send(dstSocket, p, strlen(p), 0) < 0)) {
					perror("send(cmd) err");
					free(p);
					exit(1);
				}
			}
			free(p);

			if ((send(dstSocket, "\n", 1, 0) < 0)) {
				perror("send(\\n) err");
				exit(1);
			}
		}
#else
		char buf[2], line[1024];
		int c, i = 0;

		while (1) {
			if ((c = getchar()) == EOF) {	// ctrl-d pressed
				send(dstSocket, "exit\n", 5, 0);
				printf("exit\n");
				break;
			}
			if (c == '\n' || i == 1023) {
				line[i] = 0;
				i = 0;
				if (strcmp(line, "diag") == 0)
					system("diag");
			} else {
				line[i] = c;
				i++;
			}
			buf[0] = c;
			// only sending 1 char
			if ((send(dstSocket, buf, 1, 0) < 0)) {
				perror("send(cmd) err");
				exit(1);
			}
		}
#endif
	}

	printf("cwmp: recv thread non-expected terminated\n");
	return 0;
}
